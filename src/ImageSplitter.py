#!/usr/bin/env python3

import numpy
from PIL import Image

'''
    ImageSplitter
        Convert image to numpy arrays
'''

class ImageSplitter():
    channels = 3
    mode = "RGB"

    def __init__(self, channels=3):
        self.channels = 3
        self.mode = "RGB" if self.channels == 3 else "L"

    '''
        Get an image from numpy data. Format: HWC
    '''
    def getImageFromData(self, data):
        pix = numpy.array(numpy.uint8(data))
        h, w, c = pix.shape
        if c == 1:
            pix = pix.reshape(h, w)
        return Image.fromarray(pix)

    '''
        Get data from image. Format: HWC
    '''
    def getDataFromImage(self, img):
        data = numpy.asarray(img)
        if len(data.shape) == 2:
            h, w = data.shape
            data = data.reshape(h, w, 1)
        return data

    '''
        Split an image in regions of given size.
            - img: Image to split
            - size: size of the regions to be returned
            - padding: add padding to process all the image or not
            - stride: tuple with the stride between two nearby regions
        Generates: array of images
    '''
    def splitImage(self, img, size, padding=False, stride=None):
        if stride is None:
            stride = size
        width, height = img.size
        split_w, split_h = size
        stride_w, stride_h = stride
        if padding:
            diff_w = (split_w - width) % stride_w
            diff_h = (split_h - height) % stride_h
            base_size = (width + diff_w, height + diff_h)
        else:
            base_size = (width, height)
        # Create image to split
        color = (0,0,0) if self.channels == 3 else 0
        base_img = Image.new(self.mode, base_size, color=color)
        base_img.paste(img, (0,0))
        # Iterate
        base_width, base_height = base_size
        a = numpy.floor((base_width - split_w) / stride_w) + 1
        b = numpy.floor((base_height - split_h) / stride_h) + 1
        for i in range(int(a)):
            for j in range(int(b)):
                index = i * b + j
                x = i * stride_w
                y = j * stride_h
                yield base_img.crop((x, y, x + split_w, y + split_h))
        return None

    '''
        Recompose an image from the splits generated by splitImage (with padding = True)
            - splits: numpy array
            - original_size: original size of the image
            - stride: tuple with the stride used to split the image
            - resolver: function to be used to choose the color on the overlapping areas
            Note: resolver should take as input a 1-dimensional array and return a number
                  The array represents the values on a given pixel where the value -1 should be ignored
                  e.g. [-1, 0.0, -1, -1, 1.0, 0.5] means the pixel has values 0.0, 1.0 and 0.5
            Returns: numpy array with the image data
    '''
    def recomposeImage(self, splits, original_size, stride=None, resolver=None):
        data = self._getImageDataFromSplits(splits, original_size, stride)
        if resolver is None:
            # Default resolver:
            #  average the input ignoring negative values
            def avg_resolver(a):
                valid_values = []
                for i in a:
                    if i >= 0.0:
                        valid_values.append(i)
                if len(valid_values) == 0:
                    return 0.0
                valid_values = numpy.asarray(valid_values)
                return numpy.mean(valid_values)
                '''
                tot = 0.0
                n = 0
                for i in a:
                    if i >= 0.0:
                        tot += i
                        n += 1
                if n > 0:
                    return 1.0 * tot / n
                else:
                    return 0.0
                '''
            resolver = avg_resolver
        # Apply the resolver along the last axis
        img = numpy.apply_along_axis(resolver, -1, data)
        return img

    def _getImageDataFromSplits(self, splits, base_size, stride=None):
        split_shape = splits[0].shape
        if len(split_shape) == 3:
            split_h, split_w, _ = split_shape
            channels = 3
        else:
            split_h, split_w = split_shape
            channels = 1
        if stride is None:
            stride = (split_w, split_h)
        stride_w, stride_h = stride
        # Convert split and stride to int
        split_w = int(split_w)
        split_h = int(split_h)
        stride_w = int(stride_w)
        stride_h = int(stride_h)
        # Get the max number of splits overlapping in the same area
        max_overlap_w = numpy.ceil(split_w / stride_w)
        max_overlap_h = numpy.ceil(split_h / stride_h)
        max_overlap = int(max_overlap_w * max_overlap_h)
        # Get base image size
        width, height = base_size
        a = numpy.ceil((width - split_w) / stride_w) + 1
        b = numpy.ceil((height - split_h) / stride_h) + 1
        width_padded = int(split_w + (a-1) * stride_w)
        height_padded = int(split_h + (b-1) * stride_h)
        a = int(a)
        b = int(b)
        # Create base image (HWC)
        base_size = (height_padded, width_padded, channels, max_overlap)
        base = -1 * numpy.ones(base_size, dtype="float32")
        for i in range(a):
            for j in range(b):
                index = i * b + j
                # Image format is HWC
                y0 = i * stride_w
                x0 = j * stride_h
                y1 = y0 + split_w
                x1 = x0 + split_h
                level = (j % max_overlap_h) * max_overlap_w + (i % max_overlap_w)
                level = int(level)
                base[x0:x1, y0:y1, :, level] = splits[index].reshape(split_h, split_w, channels)
        return base
